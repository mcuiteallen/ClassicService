//const querystring = require('querystring');
const request = require('request');


module.exports = class dbmsHttp {

    constructor( address = '127.0.0.1', port = 8085 ) {
        this.dbms_site = 'http://' + address + ':' + port;
        console.error('dbms info= ' + this.dbms_site );
    };


    //  Influx Function 
    /**
     * @param {String} measurement : tableName
     * @param {JSON} tags  : { "name": "kobe", "id": "123" }
     * @param {JSON} fields : { "column1": "test1", "column2": "test2" }
     * @param {Unix Time ms} insertTime : 1603700017052
     * @param {String} dbName : e2i
     */      
    insertInfluxData(measurement, tag, fields, time, dbName) {
        return new Promise( async (resolve, reject) => {
            let data = [];
            let obj = {measurement: measurement, fields: fields, time: time};
            if(tag != 'none'){
                obj['tag'] = tag;
            }
            data.push(obj);
            let post_data = {
                'dbName': dbName,
                'data': data
            };
    
            // An object of options to indicate where to post to
            let options = {
                //uri: 'http://localhost:8085/influxdb/insertData',
                uri: this.dbms_site +'/influxdb/insertData',
                method: 'POST',
                json: post_data            
            };
            // post the data
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };
    /**
     * @param {String} measurement : tableName
     * @param {JSON} tags  : 'none' or [{"logic":"&&", "key":"name", "val": "kobe", "conditions":"="}, {"logic":"&&", "key":"id", "val": "123", "conditions":"="}]
     * @param {Array} fields : "none" or ["field1", "field2", "field3"]
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"field3", "val": true, "conditions":"="}, {"logic":"&&", "key":"field2", "val": "text", "conditions":"="}, {"logic":"&&", "key":"field1", "val": "0", "conditions":">"}]
     * @param {Unix Time ms} startTime : 1603700017052
     * @param {Unix Time ms} endTime : 1603700017053
     * @param {String} dbName : e2i
     */  
    queryInfluxData( measurement, tags, fields , subQuery, startTime, endTime, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {measurement: measurement, startTime: startTime, endTime: endTime };

            if( tags != 'none') {
                    query['tags'] = tags;
            }
    
            if( fields != 'none' ){
                query['fields'] = fields;
            }
    
            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/influxdb/queryData',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    }; 
    /**
        let formData =  {
            myCsv: fs.createReadStream('./testTable_1603707222160.csv'),
            measurement: 'testCsvTable',
            dbName: 'testDB'
        } 
     */  
    importInfluxData(formData) {
        return new Promise( async (resolve, reject) => {
            let options = {
                headers: {
                    "Content-Type": "multipart/form-data"
                },                
                uri: this.dbms_site + '/influxdb/importCsv',
                method: 'POST',
                formData: formData  
            };  
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    };     
    /**
     * @param {String} measurement : tableName
     * @param {JSON} tags  : 'none' or [{"logic":"&&", "key":"name", "val": "kobe", "conditions":"="}, {"logic":"&&", "key":"id", "val": "123", "conditions":"="}]
     * @param {Array} fields : "none" or ["field1", "field2", "field3"]
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"field3", "val": true, "conditions":"="}, {"logic":"&&", "key":"field2", "val": "text", "conditions":"="}, {"logic":"&&", "key":"field1", "val": "0", "conditions":">"}]
     * @param {Unix Time ms} startTime : 1603700017052
     * @param {Unix Time ms} endTime : 1603700017053
     * @param {String} dbName : e2i
     */  
    exportInfluxData( measurement, tags, fields , subQuery, startTime, endTime, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {measurement: measurement, startTime: startTime, endTime: endTime };

            if( tags != 'none') {
                    query['tags'] = tags;
            }
    
            if( fields != 'none' ){
                query['fields'] = fields;
            }
    
            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/influxdb/exportCsv',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    /**
     * @param {String} dbName : e2i
     * @param {Number} duration : 5       // unit is hour 
     */      
    updateInfluxDuration(dbName, duration) {
        let post_data = {
            'dbName': dbName,
            'duration': duration
        };         
        return new Promise( async (resolve, reject) => {     
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/influxdb/updateDuration',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    /**
     * @param {Array} dbNameArray : ["testDB", "testDB2"]
     */      
    dropInfluxDB(dbNameArray) {
        let post_data = {
            'dbName': dbNameArray,
        };            
        return new Promise( async (resolve, reject) => {       
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/influxdb/dropDatabase',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };      
    getDBListInfluxData() {
        return new Promise( async (resolve, reject) => {
            let options = {
                uri: this.dbms_site + '/influxdb/getDatabases',
                method: 'GET'         
            };
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    getMeasurementListInfluxData(dbName) {
        return new Promise( async (resolve, reject) => {
            let options = {
                uri: this.dbms_site + '/influxdb/getMeasurements/' + dbName,
                method: 'GET'         
            };
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    };      
    
    
    //  SQLite Function 
    /**
     * @param {String} tableName 
     * @param {JSON} columns : [{ "name": "column1", "type": "TEXT"}, { "name": "column2", "type": "INTEGER"}]
     * @param {Array} values : [["testText1", test123], ["testText2", test1234]]		
     * @param {String} dbName 
     */       
    insertSqliteData(tableName, columns, values, dbName) {
        return new Promise( async (resolve, reject) => {
            let post_data = {
                'dbName': dbName,
                'tableName': tableName,
                'columns': columns,
                'values': values
            };
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site +'/sqlite/insertData',
                method: 'POST',
                json: post_data            
            };
            // post the data
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });     
        });
    };    
    /**
     * @param {String} tableName 
     * @param {Array} columns : "none" or ["age", "faceid"]
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"age", "val": 20, "conditions":">"}]
     * @param {String} dbName 
     */      
    querySqliteData( tableName, columns , subQuery, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {tableName: tableName};

            if( columns != 'none' ){
                query['columns'] = columns;
            }
    
            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/sqlite/queryData',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
   
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    /**
     * @param {String} tableName 
     * @param {String} column : "column1"
     * @param {String} value : "value" 
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"age", "val": 20, "conditions":">"}]
     * @param {String} dbName 
     */      
    updateSqliteData( tableName, column , value, subQuery, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {tableName: tableName, column: column, value: value};

            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/sqlite/updateData',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };    
    /**
     * @param {String} tableName 
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"age", "val": 20, "conditions":">"}]
     * @param {String} dbName 
     */      
    deleteSqliteData( tableName, subQuery, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {tableName: tableName};

            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/sqlite/deleteData',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    /**
     * @param {String} tableName 
     * @param {Array} columns : "none" or ["age", "faceid"]
     * @param {JSON} subQuery : "none" or [{"logic":"&&", "key":"age", "val": 20, "conditions":">"}]
     * @param {String} dbName 
     */     
    exportSqliteData( tableName, columns , subQuery, dbName) {
        return new Promise( async (resolve, reject) => {
            let query = {tableName: tableName};

            if( columns != 'none' ){
                query['columns'] = columns;
            }
    
            if( subQuery != 'none' ) {
                query['subQuery'] = subQuery;
            }
    
            let post_data = {
                'dbName': dbName,
                'query': query
            };       
    
            // An object of options to indicate where to post to
            let options = {
                uri: this.dbms_site + '/sqlite/exportData',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };   
    /**
        let formData =  {
            myCsv: fs.createReadStream('./testTable_1603358956231.csv'),
            measurement: 'testCsvTable',
            dbName: 'testDB'
        } 
     */       
    importSqliteData(formData) {
        return new Promise( async (resolve, reject) => {
            let options = {
                headers: {
                    "Content-Type": "multipart/form-data"
                },                
                uri: this.dbms_site + '/sqlite/importCsv',
                method: 'POST',
                formData: formData  
            };  
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    }; 
    getSchemaByDBSqliteData(dbName) {
        return new Promise( async (resolve, reject) => {
            let options = {
                uri: `${this.dbms_site}/sqlite/getSchema/${dbName}`,
                method: 'GET'         
            };
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    };      
    getDBListSqliteData() {
        return new Promise( async (resolve, reject) => {
            let options = {
                uri: this.dbms_site + '/sqlite/getDatabases',
                method: 'GET'         
            };
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(JSON.parse(body));           
                }else{
                    reject(error);       
                }
            });  
        });
    };  
    /**
     * @param {String} tableName 
     * @param {String} dbName 
     */      
    dropTableSqliteData(dbName, tableName) {
        return new Promise( async (resolve, reject) => {
            let post_data = {
                dbName: dbName,
                tableName: tableName
            };
            let options = {
                uri: this.dbms_site + '/sqlite/dropTable',
                method: 'POST',
                json: post_data            
            };
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };   
    /**
     * @param {String} dbName 
     */           
    dropDBSqliteData(dbName) {
        return new Promise( async (resolve, reject) => {
            let post_data = {
                dbName: dbName
            };
            let options = {
                uri: this.dbms_site + '/sqlite/dropDB',
                method: 'POST',
                json: post_data            
            };
            // post the data
    
            //console.log('query ='+ JSON.stringify(options));
    
            request(options, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    resolve(body);           
                }else{
                    reject(error);       
                }
            });  
        });
    };                      
}
