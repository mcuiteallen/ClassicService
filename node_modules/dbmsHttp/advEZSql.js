const dbmsHttp = require('./dbms-http.js');



const DB_TYPE = { 
    NONE:     0,
    InfluxDB: 1,
    SQLite:   2
}

const DBStatus = {     
    NO_TABLE:         -101,  // TABLE is not created => must insert a data at first
    SCHEMA_ERROR:     -100,  // App's schema is not compability with table's schema => can't use to update / insert data
    UNAVAILIABLE:       -1,  // DBMS is not available => need to retry until service is available    
    INITIALIZE:          0,  // Initialize status    
    READY  :             1   // Ready to use: DBMS service is running and schema is correct.
};

const DBCode = {    
    QUEUE_IS_FULL:     -3,
    FORMAT_ERROR:      -2,
    FAILED:            -1,    
    OK:                 0,
    PROCESSING:         1,
}

var advEZSql = class {   
    
    // *********** External function  ******************************
    /**
     * 
     * @param {String} dbname  : Name of database
     * @param {String} table   : Name of table
     * @param {JSON}   schema  : {"name":"TEXT","status":"INTEGER","status_time":"INTEGER","capability":"TEXT","last_data":"TEXT","last_time":"INTEGER"}
     * @param {String} dbtype  : Type of database ( ex: DB_TYPE.SQLite ) 
     */
    constructor( dbname, table, schema,  dbtype = DB_TYPE.SQLite, adress = '127.0.0.1', port = 8085 ) {
        
        if( typeof dbname == 'undefined' || dbname == '' || typeof table == 'undefined' || table == '' || 
            typeof schema !== 'object' ) return undefined;       

        
        this.aSchema     = [];                                        // [{"name":"TEXT"}, {"status":"INTEGER"},{"status_time":"INTEGER"}, {"capability":"TEXT"},{"last_data":"TEXT"},{"last_time":"INTEGER"}]            
        this.length      = 0;
        this.iSchema     = [];                                        // [{"name": "name","type": "TEXT"},{"name": "status","type": "INTEGER"}...]
        this.dbname      = dbname;
        this.tableName   = table;
        this.dbtype      = dbtype;    
        this.status      = DBStatus.INITIALIZE;    
        this.schema      = JSON.parse(JSON.stringify(schema));      // {"name":"TEXT","status":"INTEGER","status_time":"INTEGER","capability":"TEXT","last_data":"TEXT","last_time":"INTEGER"};
        this.schemaJS    = {};                                      // {"name":"string","status":"number","status_time":"number","capability":"string","last_data":"string","last_time":"number"};
        this.aschemaName = [];                                      // ["name", "status", "status_time"..]
        this.aschemaType = [];                                      // ["string","number","number","string","string","number"];
        this.maxUQ       = 100;
        this.maxIQ       = 100;
        this.uQueue      = [];
        this.iQueue      = [];                                       // Insert {JSON Obj}, push, pop ( get & remove the top of stack )
        this.iInterval   = 0;
        this.uInterval   = 0;
                  
        this.DbmsHttp    = new dbmsHttp(adress, port);   
        
        var tmp = [];
        var ret = DBStatus.INITIALIZE;

        // Check the schema limitation: Name can't include space character. Supports 'TEXT' and 'INTEGER' only.
        var aTmp = {};
        var iTmp = [];
        var cTmp = [];
        var dTmp = [];
        Object.keys(schema).forEach(function(k) {
            var column = {};
            if(k.includes(' ') || ( schema[k] !== 'TEXT' && schema[k] !== 'INTEGER') ) {
                ret = DBStatus.SCHEMA_ERROR;
                return null;
            } else
            {
                if( schema[k] === 'TEXT')
                {
                    cTmp.push('string');
                    aTmp[k] = 'string';
                    dTmp.push(k);
                } 
                else if( schema[k] === 'INTEGER' )
                {
                    aTmp[k] = 'number';
                    cTmp.push('number');
                    dTmp.push(k);
                }

                column[k] = schema[k];
                tmp.push(column);

                var column = {};
                column.name = k;
                column.type = schema[k];
                iTmp.push(column);                
            }
        }); 
        

        if( ret ==  DBStatus.SCHEMA_ERROR ) {
            this.status = ret;
            return null;
        } else{
            this.length = tmp.length;

            this.schemaJS = JSON.parse(JSON.stringify(aTmp));

            tmp.forEach(element=>{
                this.aSchema.push(element);
            });

            iTmp.forEach(element=>{
                this.iSchema.push(element);
            });

            cTmp.forEach(element=>{
                this.aschemaType.push(element);
            });     
            
            dTmp.forEach(element=>{
                this.aschemaName.push(element);
            });  
            

            this.check_sqlTable(this);
        }         
    };

    

    getStatus = function( ) {
        return  this.status;
    };

    startAction  = function( obj )
    {
        if( obj.iInterval == 0 ) 
          obj.iInterval = setInterval( obj.insertAction, 1000, obj ); 
          
        if( obj.uInterval == 0 )
          obj.uInterval = setInterval ( obj.updateAction, 1000, obj );
    }

    stopAction  = function( obj )
    {
        if( obj.iInterval !== 0 ) {
            clearTimeout( obj.iInterval);
            obj.iInterval = 0;
        }

        if( obj.uInterval !== 0 ) {
            clearTimeout( obj.uInterval);
            obj.uInterval = 0;
        }        
    }

    insertAction = async function( obj ){

        if( obj.iQueue.length == 0 ) {
           console.debug('No New Insert Data !');
           return;
        }

        var size  = obj.iQueue.length;
  
        //console.debug('insertAction table= ' +obj.tableName + ' schema= ' + JSON.stringify(obj.iSchema) + ' data= ' + obj.iQueue );  
        // for each to set the values

        if( obj.dbtype == DB_TYPE.SQLite) {
            try {
                var data = await obj.DbmsHttp.insertSqliteData(obj.tableName, obj.iSchema, obj.iQueue, obj.dbname); 
                obj.iQueue.splice(0,size);       
            } catch (error) {    
                console.error('[Failed] Insert SQLite Code= ' + error );
                obj.reconnect( obj );      
            }
        }
    }


    updateAction = async function( obj ){

        if( obj.uQueue.length == 0 ) {
           console.debug('No New Update Data !');
           return;
        }
  
        // console.log('updateAction table= ' +obj.tableName );  

        if( obj.dbtype == DB_TYPE.SQLite) {
            try {
                  var data = await obj.DbmsHttp.updateSqliteData(obj.tableName, obj.uQueue[0].columns, obj.uQueue[0].values, obj.uQueue[0].query, obj.dbname);
                  obj.uQueue.splice(0,1); // remove 
                  obj.updateAction( obj );  
            } catch (error) {    
                  console.error('[Failed] Update SQL Failed Code= ' + error );  
                  obj.reconnect( obj );
            }
        }                  
    }   
    
    /**
     * 
     * @param {JSON} jvalues : {"status":1,"status_time":12345 }
     * @param {*} jquery : 'none' or  [{"logic":"&&", "key":"name", "val": "Modbus-Master", "conditions":"="}]
     */    
    updateDataImm = async function( jvalues, jquery )   
    {
        return new Promise( async (resolve, reject) => {

            if( this.status == DBStatus.SCHEMA_ERROR )
                reject(DBCode.FAILED);
                    
            var status = DBCode.FAILED;  
            var data = {}; // {"columns":["status","status_time"], "values":[1, 12345]}
            data.columns = [];     
            data.values  = [];  
            if( typeof jquery === 'object') 
                data.query  = JSON.parse(JSON.stringify(jquery));
            else
                data.query  = 'none';

            var tmp = this.schemaJS; // {"name":"string","status":"number","status_time":"number","capability":"string","last_data":"string","last_time":"number"};        
            Object.keys(jvalues).forEach(function(k) {
                if(typeof tmp[k] === 'undefined' || typeof jvalues[k] !== tmp[k] )
                    status =  DBCode.FORMAT_ERROR;
                else {
                    data.columns.push(k);
                    data.values.push(jvalues[k]);
                }
            });         

            if( status == DBCode.FORMAT_ERROR ) 
                reject(DBCode.FORMAT_ERROR); 


            if( this.dbtype == DB_TYPE.SQLite )
            {
                try {
                    var data = await this.DbmsHttp.updateSqliteData(this.tableName, data.columns, data.values, data.query, this.dbname);

                    console.debug('[OK] Sync Update SQL Reply= ' + JSON.stringify(data));  
                    resolve(data);

                } catch (error) {    
                    console.error('[Failed] Update SQL code = ' + error );  
                    this.reconnect( this );
                    reject(DBCode.FAILED); 
                }
            }                                      
        });
    }

    /**
     * 
     * @param {JSON} jvalues : {"status":1,"status_time":12345 }
     * @param {*} jquery : 'none' or  [{"logic":"&&", "key":"name", "val": "Modbus-Master", "conditions":"="}]
     */
    updateData = function( jvalues, jquery )   {

        var status = DBCode.FAILED;  
        var data = {};               // {"columns":["status","status_time"], "values":[1, 12345]}
        data.columns = [];     
        data.values  = [];  

        if( this.status == DBStatus.SCHEMA_ERROR ) {
            return DBCode.FAILED;;
         }
                 
        if( typeof jquery === 'object') 
            data.query   = JSON.parse(JSON.stringify(jquery));
        else
            data.query   = 'none';

        var tmp = this.schemaJS; // {"name":"string","status":"number","status_time":"number","capability":"string","last_data":"string","last_time":"number"};        
        Object.keys(jvalues).forEach(function(k) {
            if(typeof tmp[k] === 'undefined' || typeof jvalues[k] !== tmp[k] )
                status =  DBCode.FORMAT_ERROR;
            else {
                data.columns.push(k);
                data.values.push(jvalues[k]);
            }

        });         

        if( status == DBCode.FORMAT_ERROR ) 
            return status;        

        // 1. check queue is full 
        if( this.uQueue.length >= this.maxUQ )
            return DBCode.QUEUE_IS_FULL;
            
        this.uQueue.push(data);

        return DBCode.PROCESSING;            
    }

    /**
     * 
     * @param {JSON} values :{"name":"Test","status":1,"status_time":12345,"capability":"TestData1","last_data":"TestData2","last_time":0}
     */
    insertDataImm = async function( values ) {
        return new Promise( async (resolve, reject) => {
            if( this.status == DBStatus.SCHEMA_ERROR ) {
                reject(DBCode.FAILED);
            }
                    
            var status = DBCode.FAILED;

            // 0. check insert all columns and data type        
            if( Object.keys(values).length !== Object.keys(this.schemaJS).length ) 
                reject(DBCode.FORMAT_ERROR);

            
            var tmp = this.schemaJS; // {"name":"string","status":"number","status_time":"number","capability":"string","last_data":"string","last_time":"number"};        
            Object.keys(values).forEach(function(k) {
                if(typeof tmp[k] === 'undefined' || typeof values[k] !== tmp[k] )
                    status =  DBCode.FORMAT_ERROR;
            }); 

            if( status == DBCode.FORMAT_ERROR ) 
                reject(status);

                
            var data = []; // ["Modbus", 1, 12345, "TestCapability", "TestLast", 0] to set data set by schema order

            this.aschemaName.forEach(name=>{
            data.push(values[name]);
            });  

            var insertData = [];
            insertData.push(data);


            if( this.dbtype == DB_TYPE.SQLite )
            {
                try {
                    var data = await this.DbmsHttp.insertSqliteData(this.tableName, this.iSchema, insertData, this.dbname ); 
                    resolve( data );       
                } catch (error) {    
                    this.reconnect( this );
                    reject(code);     
                }
            }            
        });  
    };

    /**
     * 
     * @param {JSON} values :{"name":"Test","status":1,"status_time":12345,"capability":"TestData1","last_data":"TestData2","last_time":0}
     */
    insertData = function( values ) {

        if( this.status == DBStatus.SCHEMA_ERROR ) {
            return DBCode.FORMAT_ERROR;;
         }
                 
        var status = DBCode.FAILED;

        // 0. check insert all columns and data type        
        if( Object.keys(values).length !== Object.keys(this.schemaJS).length ) 
            return DBCode.FORMAT_ERROR;

        
        var tmp = this.schemaJS; // {"name":"string","status":"number","status_time":"number","capability":"string","last_data":"string","last_time":"number"};        
        Object.keys(values).forEach(function(k) {
            if(typeof tmp[k] === 'undefined' || typeof values[k] !== tmp[k] )
                status =  DBCode.FORMAT_ERROR;
        }); 

        if( status == DBCode.FORMAT_ERROR ) 
            return status;


        // 1. check queue is full 
        if( this.iQueue.length >= this.maxIQ )
            return DBCode.QUEUE_IS_FULL;
            
        var data = []; // ["Modbus", 1, 12345, "TestCapability", "TestLast", 0] to set data set by schema order

        this.aschemaName.forEach(name=>{
           data.push(values[name]);
        });  

        this.iQueue.push(data);

        return DBCode.PROCESSING;
    };

    /**
     * 
     * @param {Array} columns : ['name', 'status']
     * @param {JSONN} Query   : 'none' or  [{"logic":"&&", "key":"column2", "val": 1234, "conditions":">"},{"logic":"&&", "key":"column1", "val": "testText2", "conditions":"="}]
     */
    queryDataImm = async function( columns, Query ) {
        return new Promise( async (resolve, reject) => {
            if( this.status == DBStatus.SCHEMA_ERROR ) {
                reject( DBCode.FORMAT_ERROR );
            }

            if( this.dbtype == DB_TYPE.SQLite )
            {
                try {
                    var data = await this.DbmsHttp.querySqliteData(this.tableName, columns, Query, this.dbname );
                    resolve( data );     
                } catch (error) {    
                    reject( DBCode.FAILED );  
                    this.reconnect( this ); 
                }
            }
        });
    } 


    reconnect = function( obj, retry )
    {
        obj.status     =  DBStatus.UNAVAILIABLE;   

        if( typeof retry === 'undefined' ) return; // only one retry 

        console.error('DBMS Service is unavailable => retry!');
 
        setTimeout( obj.check_sqlTable, 1000, obj ); // retry by 1 second
    }

    /**
     * Description: To check DBMS SQL service is alive and db or table has created 
     *  -: not alive: UN
     */
    check_sqlTable =  async function( obj ) {

        if( obj.dbtype == DB_TYPE.SQLite )
        {
            try {
                var reply = await obj.DbmsHttp.getSchemaByDBSqliteData(obj.dbname);

                if( typeof reply.Result === 'undefined' ) {
                    obj.status = DBStatus.NO_TABLE;
                    return;
                }

                if( reply.Result.length == 0 )
                    obj.status = DBStatus.NO_TABLE;
                else 
                {                  
                    reply.Result.forEach( element=>{
                        if( element.name === obj.tableName )
                        {
                            var start = element.sql.indexOf('(') + 1;
                            var end   = element.sql.lastIndexOf(')');
                            var acolumnlist = element.sql.substring(start, end).split(',');

                            if( acolumnlist.length !== obj.aSchema.length ){
                                 obj.status = DBStatus.SCHEMA_ERROR;
                                 return;
                            } else {              
                                var realSchema  = {};
                                for( var i=0; i < acolumnlist.length; i++ ) {
                                    // To filter '' items
                                    var tmp = acolumnlist[i].split(' ');
                                    tmp = tmp.filter(function(item) {
                                        return item !== "";
                                    })   
                                    realSchema[tmp[0]] = tmp[1];
                                }  
                                
                                var st = DBStatus.READY;
                                Object.keys(realSchema).forEach(function(k) {
                                    if( typeof obj.schema[k] === 'undefined' || obj.schema[k] !==  realSchema[k])
                                       st = DBStatus.SCHEMA_ERROR;
                                });   
                                obj.status = st;   

                                if( obj.status == DBStatus.READY ) {
                                    console.log('DBMS Service is OK and Start Action');
                                    obj.startAction( obj );    
                                }
                                return;                          
                            }
                        }
                    }); // End of forEach
                 }  // End of reply.Result.length > 0                                                             
            } 
            catch (error) {    
                obj.reconnect( obj, true );    // Service is Unavailable      
            }        
        }     
    };    
};

module.exports = advEZSql;

module.exports.DBStatus = DBStatus;

module.exports.DB_TYPE  = DB_TYPE;